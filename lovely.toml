[manifest]
version = "1.0.0"
dump_lua = true
priority = 1

# ------------------------------------------ JOKERS ------------------------------------------
# Add Trick or Treak Functionality --------------------------------------

    # Apply modifier to pack choice
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.GAME.pack_choices = self.config.center.config.choose or 1"
position = "after"
payload = '''
G.GAME.pack_choices = G.GAME.pack_choices + G.GAME.choose_mod
'''
match_indent = true
times = 1


    # Add modifier to definitions
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = 'vars = { cfg.choose, cfg.extra },'
position = "at"
payload = 'vars = { cfg.choose + G.GAME.choose_mod, cfg.extra },'
match_indent = true
timer = 1






# Add Egg Explosion Functionality -----------------------------------------

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Egg' then
    self.ability.extra_value = self.ability.extra_value + self.ability.extra
    self:set_cost()
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_microwave')) and pseudorandom('eggsplode' .. G.GAME.round_resets.ante, 1, 20) == 1 then
    G.E_MANAGER:add_event(Event({
        func = function()
            play_sound('mxms_eggsplosion')
            ease_dollars(self.sell_cost)
            self:start_dissolve({G.C.ORANGE}, nil, 1.6)
            return true;
        end
    }))
    return {
        message = 'Exploded...',
        colour = G.C.MONEY
    }
end
'''
match_indent = true
times = 1




# Add Faded Joker Functionality -----------------------------------------

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if next(find_joker('Smeared Joker')) and (self.base.suit == 'Hearts' or self.base.suit == 'Diamonds') == (suit == 'Hearts' or suit == 'Diamonds') then
    return true
end
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_faded')) and (self.base.suit == 'Spades' or self.base.suit == 'Diamonds') == (suit == 'Spades' or suit == 'Diamonds') then
    return true
end
'''
match_indent = true
times = 2

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if next(find_joker('Smeared Joker')) and (self.base.suit == 'Hearts' or self.base.suit == 'Diamonds') == (suit == 'Hearts' or suit == 'Diamonds') then
    return true
end
'''
position = "before"
payload = '''
if next(SMODS.find_card('j_mxms_faded')) and next(find_joker('Smeared Joker')) then
    return true
end
'''
match_indent = true
times = 2




# Add War Functionality -------------------------------------------------

    #Change limits and description for Trading Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 then"
position = "at"
payload = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 * G.GAME.war_mod then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Trading Card' then loc_vars = {self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Trading Card' then loc_vars = {self.ability.extra, self.ability.destroy * G.GAME.war_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
j_trading=          {order = 95,   unlocked = true, discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = "Trading Card",set = "Joker", config = {extra = 3}, pos = {x=9,y=14}},
'''
position = "at"
payload = '''
j_trading=          {order = 95,   unlocked = true, discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = "Trading Card",set = "Joker", config = {extra = 3, destroy = 1}, pos = {x=9,y=14}},
'''
match_indent = true


    #Change limits and description for Sixth Sense (includes Perspective Functionality to reduce patches)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.name == 'Sixth Sense' and #context.full_hand == 1 and context.full_hand[1]:get_id() == 6 and G.GAME.current_round.hands_played == 0 then"
position = "at"
payload = '''
    if self.ability.name == 'Sixth Sense' and #context.full_hand <= 1 * G.GAME.war_mod and G.GAME.current_round.hands_played == 0 then
        for i = 1, #context.full_hand do
            if not (context.full_hand[i]:get_id() == 6 or (next(SMODS.find_card('j_mxms_perspective')) and context.full_hand[1]:get_id() == 9)) then
                return
            end
        end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Sixth Sense' then loc_vars = {}"
position = "at"
payload = "elseif self.ability.name == 'Sixth Sense' then loc_vars = {self.ability.destroy * G.GAME.war_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
j_sixth_sense=      {order = 54,  unlocked = true,  discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = 'Sixth Sense', pos = {x = 8, y = 10}, set = 'Joker', config = {}},
'''
position = "at"
payload = '''
j_sixth_sense=      {order = 54,  unlocked = true,  discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = 'Sixth Sense', pos = {x = 8, y = 10}, set = 'Joker', config = {destroy = 1}},
'''
match_indent = true
times = 1


    #Change limits and description for Immolate
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "for i = 1, self.ability.extra.destroy do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end"
position = "at"
payload = "for i = 1, self.ability.extra.destroy * G.GAME.war_mod do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "elseif _c.name == 'Immolate' then loc_vars = {cfg.extra.destroy, cfg.extra.dollars}"
position = "at"
payload = "elseif _c.name == 'Immolate' then loc_vars = {cfg.extra.destroy * G.GAME.war_mod, cfg.extra.dollars}"
match_indent = true
times = 1


    #Change limits and description for Hanged Man
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.consumeable and self.ability.consumeable.max_highlighted then
    self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted)
end
'''
position = "at"
payload = '''
if self.ability.consumeable and self.ability.consumeable.max_highlighted then
    if self.ability.name == 'The Hanged Man' then
        self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted * G.GAME.war_mod)
    else
        self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted)
    end
end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "The Hanged Man" then loc_vars = {cfg.max_highlighted}
'''
position = "at"
payload = '''
elseif _c.name == "The Hanged Man" then loc_vars = {cfg.max_highlighted * G.GAME.war_mod}
'''
match_indent = true
times = 1


    #Change limits for Grim, Incantation, and Familiar
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = '''
local function random_destroy(used_tarot)
    local destroyed_cards = {}
    destroyed_cards[#destroyed_cards + 1] = pseudorandom_element(G.hand.cards, pseudoseed('random_destroy'))
'''
position = "at"
payload = '''
local function random_destroy(used_tarot)
    local destroyed_cards = {}
    for i = 1, used_tarot.ability.destroy * G.GAME.war_mod do
        destroyed_cards[#destroyed_cards + 1] = pseudorandom_element(G.hand.cards, pseudoseed('random_destroy'..i))
    end
'''
match_indent = true
times = 1


    #Change descriptions for Grim, Incantation, and Familiar
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if _c.name == 'Familiar' or _c.name == 'Grim' or _c.name == 'Incantation' then loc_vars = {cfg.extra}"
position = "at"
payload = "if _c.name == 'Familiar' or _c.name == 'Grim' or _c.name == 'Incantation' then loc_vars = {cfg.extra, cfg.destroy * G.GAME.war_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
c_familiar=         {order = 1,    discovered = false, cost = 4, consumeable = true, name = "Familiar", pos = {x=0,y=4}, set = "Spectral", config = {remove_card = true, extra = 3}},
c_grim=             {order = 2,    discovered = false, cost = 4, consumeable = true, name = "Grim",     pos = {x=1,y=4}, set = "Spectral", config = {remove_card = true, extra = 2}},
c_incantation=      {order = 3,    discovered = false, cost = 4, consumeable = true, name = "Incantation", pos = {x=2,y=4}, set = "Spectral", config = {remove_card = true, extra = 4}},
'''
position = "at"
payload = '''
c_familiar=         {order = 1,    discovered = false, cost = 4, consumeable = true, name = "Familiar", pos = {x=0,y=4}, set = "Spectral", config = {remove_card = true, extra = 3, destroy = 1}},
c_grim=             {order = 2,    discovered = false, cost = 4, consumeable = true, name = "Grim",     pos = {x=1,y=4}, set = "Spectral", config = {remove_card = true, extra = 2, destroy = 1}},
c_incantation=      {order = 3,    discovered = false, cost = 4, consumeable = true, name = "Incantation", pos = {x=2,y=4}, set = "Spectral", config = {remove_card = true, extra = 4, destroy = 1}},
'''
match_indent = true
times = 1







# Add Perspective Functionality -----------------------------------------

    #Mail-in Rebate flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Mail-In Rebate' and
not context.other_card.debuff and
context.other_card:get_id() == G.GAME.current_round.mail_card.id then
    ease_dollars(self.ability.extra)
    return {
        message = localize('$')..self.ability.extra,
        colour = G.C.MONEY,
        card = self
    }
end
'''
position = "at"
payload = '''
if self.ability.name == 'Mail-In Rebate' and
not context.other_card.debuff then
    if context.other_card:get_id() == G.GAME.current_round.mail_card.id 
    or (next(SMODS.find_card('j_mxms_perspective')) and 
    ((context.other_card:get_id() == 9 and G.GAME.current_round.mail_card.id == 6) 
    or (context.other_card:get_id() == 6 and G.GAME.current_round.mail_card.id == 9))) then
        ease_dollars(self.ability.extra)
        return {
            message = localize('$')..self.ability.extra,
            colour = G.C.MONEY,
            card = self
        }
    end
end
'''
match_indent = true
times = 1


    #The Idol flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'The Idol' and
    context.other_card:get_id() == G.GAME.current_round.idol_card.id and 
    context.other_card:is_suit(G.GAME.current_round.idol_card.suit) then
        return {
            x_mult = self.ability.extra,
            colour = G.C.RED,
            card = self
        }
    end
'''
position = "at"
payload = '''
if self.ability.name == 'The Idol' then
    if context.other_card:get_id() == G.GAME.current_round.idol_card.id
    or (next(SMODS.find_card('j_mxms_perspective')) and 
    ((context.other_card:get_id() == 9 and G.GAME.current_round.idol_card.id == 6) 
    or (context.other_card:get_id() == 6 and G.GAME.current_round.idol_card.id == 9))) 
    and context.other_card:is_suit(G.GAME.current_round.idol_card.suit) then
        return {
            x_mult = self.ability.extra,
            colour = G.C.RED,
            card = self
        }
    end
end
'''
match_indent = true
times = 1


    #Even Steven flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Even Steven' and
context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 0
then
'''
position = "at"
payload = '''
if self.ability.name == 'Even Steven' and
((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 0) or
(next(SMODS.find_card('j_mxms_perspective')) and context.other_card:get_id() == 9))
then
'''
match_indent = true
times = 1


    #Odd Todd flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Odd Todd' and
((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 1) or
(context.other_card:get_id() == 14))
then
'''
position = "at"
payload = '''
if self.ability.name == 'Odd Todd' and
(((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 1) or
(context.other_card:get_id() == 14)) or
(next(SMODS.find_card('j_mxms_perspective')) and context.other_card:get_id() == 6))
then
'''
match_indent = true
times = 1


    #Cloud 9 flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if v:get_id() == 9 then self.ability.nine_tally = self.ability.nine_tally+1 end
'''
position = "at"
payload = '''
if v:get_id() == 9 or (next(SMODS.find_card('j_mxms_perspective')) and v:get_id() == 6) then self.ability.nine_tally = self.ability.nine_tally+1 end
'''
match_indent = true
times = 1


    #Hand detection functionality
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''
function get_X_same(num, hand, or_more)
  local vals = {}
  for i = 1, SMODS.Rank.max_id.value do
      vals[i] = {}
  end
  for i=#hand, 1, -1 do
    local curr = {}
    table.insert(curr, hand[i])
    for j=1, #hand do
      if hand[i]:get_id() == hand[j]:get_id() and i ~= j then
        table.insert(curr, hand[j])
      end
    end
'''
position = "at"
payload = '''
function get_X_same(num, hand, or_more)
  local vals = {}
  local perspective = next(SMODS.find_card('j_mxms_perspective'))
  for i = 1, SMODS.Rank.max_id.value do
      vals[i] = {}
  end
  for i=#hand, 1, -1 do
    local curr = {}
    table.insert(curr, hand[i])
    for j=1, #hand do
      if perspective and hand[i]:get_id() == 9 and hand[j]:get_id() == 6 and i ~= j then
        table.insert(curr, hand[j])
      elseif hand[i]:get_id() == hand[j]:get_id() and i ~= j then
        table.insert(curr, hand[j])
      end
    end
'''
match_indent = true
times = 1






# Set up Leftovers flags ------------------------------------------------

    #Create flag variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "destroyed_food = '',"
match_indent = true
times = 1


    #Gros Michel/Cavendish flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if pseudorandom(self.ability.name == 'Cavendish' and 'cavendish' or 'gros_michel') < G.GAME.probabilities.normal/self.ability.extra.odds then "
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Ramen flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
 if self.ability.name == 'Ramen' and not context.blueprint then
    if self.ability.x_mult - self.ability.extra <= 1 then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Ice Cream flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Ice Cream' and not context.blueprint then
    if self.ability.extra.chips - self.ability.extra.chip_mod <= 0 then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Turtle Bean flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Turtle Bean' and not context.blueprint then
    if self.ability.extra.h_size - self.ability.extra.h_mod <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Diet Cola flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Diet Cola' then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Popcorn flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Popcorn' and not context.blueprint then
    if self.ability.mult - self.ability.extra <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Seltzer flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Seltzer' and not context.blueprint then
    if self.ability.extra - 1 <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Egg flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
elseif context.selling_self then
'''
position = "after"
payload = '''
if self.ability.name == 'Egg' then
    if next(SMODS.find_card('j_mxms_leftovers')) then
        G.GAME.destroyed_food = self.config.center.key
    end
end
'''
match_indent = true
times = 1






# Add Pessimistic Functionality (including Soil Joker and Group Chat mods since Pessimistic scales ) ----------------------------------------

    # Add flag to Wheel of Fortune
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
    attention_text({
        text = localize('k_nope_ex'),
'''
position = "before"
payload = '''
local pessimistics = SMODS.find_card('j_mxms_pessimistic')
if next(pessimistics) then
    for k, v in pairs(pessimistics) do
        v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            func = function()
                v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true;
            end
        }))
    end
end
'''
match_indent = true
times = 1


    # Add flag to Glass Card Break (Stone Thrower will not scale Pessimistic)
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
for k, v in ipairs(cards_destroyed) do
    if v.shattered then glass_shattered[#glass_shattered+1] = v end
end
'''
position = "at"
payload = '''
local pessimistics = SMODS.find_card('j_mxms_pessimistic')
for k, v in ipairs(cards_destroyed) do
    if v.shattered then 
        glass_shattered[#glass_shattered+1] = v 
            if next(pessimistics) and not next(SMODS.find_card('j_mxms_stone_thrower')) then
            for kk, vv in pairs(pessimistics) do
                vv.ability.extra.mult = vv.ability.extra.mult + ((v.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        vv:juice_up(0.3, 0.4)
                        local groupchats = SMODS.find_card('j_mxms_group_chat')
                        if next(groupchats) then
                            for kkk, vvv in pairs(groupchats) do
                                vvv.ability.extra.chips = vvv.ability.extra.chips + 2 * G.GAME.soil_mod
                                vvv:juice_up(0.3, 0.4)
                            end
                        end
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Hallucination
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if pseudorandom('halu'..G.GAME.round_resets.ante) < G.GAME.probabilities.normal/self.ability.extra then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
    G.E_MANAGER:add_event(Event({
        trigger = 'before',
        delay = 0.0,
        func = (function()
            local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, 'hal')
            card:add_to_deck()
                G.consumeables:emplace(card)
                G.GAME.consumeable_buffer = 0
            return true
        end)}))
    card_eval_status_text(self, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.PURPLE})
'''
position = "after"
payload = '''
elseif next(SMODS.find_card('j_mxms_pessimistic')) then
    local pessimistics = SMODS.find_card('j_mxms_pessimistic')
    for k, v in pairs(pessimistics) do
        v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            func = function()
                v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
            return true; end
        }))
    end
'''
match_indent = true
times = 1


    # Add flag to Gros Michel/Cavendish (Includes fridge_mod so gain scales based on Refrigerator joker)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if pseudorandom(self.ability.name == 'Cavendish' and 'cavendish' or 'gros_michel') < G.GAME.probabilities.normal/self.ability.extra.odds then 
'''
position = "after"
payload = '''
local pessimistics = SMODS.find_card('j_mxms_pessimistic')
if next(pessimistics) then
    for k, v in pairs(pessimistics) do
        v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra.odds - G.GAME.probabilities.normal) * G.GAME.soil_mod)
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            func = function()
                v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true;
            end
        }))
    end
end
'''
match_indent = true
times = 1


    # Add flag to 8 Ball
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if (context.other_card:get_id() == 8) and (pseudorandom('8ball') < G.GAME.probabilities.normal/self.ability.extra) then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
    return {
        extra = {focus = self, message = localize('k_plus_tarot'), func = function()
            G.E_MANAGER:add_event(Event({
                trigger = 'before',
                delay = 0.0,
                func = (function()
                        local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, '8ba')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        G.GAME.consumeable_buffer = 0
                    return true
                end)}))
        end},
        colour = G.C.SECONDARY_SET.Tarot,
        card = self
    }
end
'''
position = "at"
payload = '''
if (context.other_card:get_id() == 8) then
    if (pseudorandom('8ball') < G.GAME.probabilities.normal/self.ability.extra) then
        G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
        return {
            extra = {focus = self, message = localize('k_plus_tarot'), func = function()
                G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.0,
                    func = (function()
                        local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, '8ba')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        G.GAME.consumeable_buffer = 0
                    return true
                end)}))
            end},
            colour = G.C.SECONDARY_SET.Tarot,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
    local pessimistics = SMODS.find_card('j_mxms_pessimistic')
        for k, v in pairs(pessimistics) do
            v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Business Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Business Card' and
    context.other_card:is_face() and
    pseudorandom('business') < G.GAME.probabilities.normal/self.ability.extra then
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + 2
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = 2,
            card = self
        }
    end
'''
position = "at"
payload = '''
if self.ability.name == 'Business Card' and
context.other_card:is_face() then
    if pseudorandom('business') < G.GAME.probabilities.normal/self.ability.extra then
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + 2
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = 2,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        local pessimistics = SMODS.find_card('j_mxms_pessimistic')
        for k, v in pairs(pessimistics) do
            v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Bloodstone
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name ==  'Bloodstone' and
context.other_card:is_suit("Hearts") and 
pseudorandom('bloodstone') < G.GAME.probabilities.normal/self.ability.extra.odds then
    return {
        x_mult = self.ability.extra.Xmult,
        card = self
    }
end
'''
position = "at"
payload = '''
if self.ability.name ==  'Bloodstone' and
context.other_card:is_suit("Hearts") then 
    if pseudorandom('bloodstone') < G.GAME.probabilities.normal/self.ability.extra.odds then
        return {
            x_mult = self.ability.extra.Xmult,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        local pessimistics = SMODS.find_card('j_mxms_pessimistic')
        for k, v in pairs(pessimistics) do
            v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Reserved Parking
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Reserved Parking' and
context.other_card:is_face() and
pseudorandom('parking') < G.GAME.probabilities.normal/self.ability.extra.odds then
    if context.other_card.debuff then
        return {
            message = localize('k_debuffed'),
            colour = G.C.RED,
            card = self,
        }
    else
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + self.ability.extra.dollars
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = self.ability.extra.dollars,
            card = self
        }
    end
end
'''
position = "at"
payload = '''
if self.ability.name == 'Reserved Parking' and
context.other_card:is_face() then
    if pseudorandom('parking') < G.GAME.probabilities.normal/self.ability.extra.odds then
        if context.other_card.debuff then
            return {
                message = localize('k_debuffed'),
                colour = G.C.RED,
                card = self,
            }
        else
            G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + self.ability.extra.dollars
            G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
            return {
                dollars = self.ability.extra.dollars,
                card = self
            }
        end
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        local pessimistics = SMODS.find_card('j_mxms_pessimistic')
        for k, v in pairs(pessimistics) do
            v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Space Joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Space Joker' and pseudorandom('space') < G.GAME.probabilities.normal/self.ability.extra then
    return {
        card = self,
        level_up = true,
        message = localize('k_level_up_ex')
    }
end
'''
position = "at"
payload = '''
if self.ability.name == 'Space Joker' then
    if pseudorandom('space') < G.GAME.probabilities.normal/self.ability.extra then
        return {
            card = self,
            level_up = true,
            message = localize('k_level_up_ex')
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        local pessimistics = SMODS.find_card('j_mxms_pessimistic')
        for k, v in pairs(pessimistics) do
            v.ability.extra.mult = v.ability.extra.mult + ((self.ability.extra - G.GAME.probabilities.normal) * G.GAME.soil_mod)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                local groupchats = SMODS.find_card('j_mxms_group_chat')
                if next(groupchats) then
                    for kk, vv in pairs(groupchats) do
                        vv.ability.extra.chips = vv.ability.extra.chips + 2 * G.GAME.soil_mod
                        vv:juice_up(0.3, 0.4)
                    end
                end
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1






# Refrigerator Functionality --------------------------------------

    # Add hook to Gros Michel/Cavendish
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Gros Michel' then loc_vars = {self.ability.extra.mult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds}"
position = "at"
payload = "elseif self.ability.name == 'Gros Michel' then loc_vars = {self.ability.extra.mult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds * G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Cavendish' then loc_vars = {self.ability.extra.Xmult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds}"
position = "at"
payload = "elseif self.ability.name == 'Cavendish' then loc_vars = {self.ability.extra.Xmult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds * G.GAME.fridge_mod}"
match_indent = true
times = 1


    # Add hook to Ice Cream
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Ice Cream' then loc_vars = {self.ability.extra.chips, self.ability.extra.chip_mod}"
position = "at"
payload = "elseif self.ability.name == 'Ice Cream' then loc_vars = {self.ability.extra.chips, self.ability.extra.chip_mod / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra.chips - self.ability.extra.chip_mod <= 0 then "
position = "at"
payload = "if self.ability.extra.chips - (self.ability.extra.chip_mod / G.GAME.fridge_mod) <= 0 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.extra.chips = self.ability.extra.chips - self.ability.extra.chip_mod"
position = "at"
payload = "self.ability.extra.chips = self.ability.extra.chips - (self.ability.extra.chip_mod / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_chips_minus',vars={self.ability.extra.chip_mod}},"
position = "at"
payload = "message = localize{type='variable',key='a_chips_minus',vars={self.ability.extra.chip_mod / G.GAME.fridge_mod}},"
match_indent = true
times = 1




    # Add hook to Turtle Bean
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Turtle Bean' then loc_vars = {self.ability.extra.h_size, self.ability.extra.h_mod}"
position = "at"
payload = "elseif self.ability.name == 'Turtle Bean' then loc_vars = {self.ability.extra.h_size, self.ability.extra.h_mod / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra.h_size - self.ability.extra.h_mod <= 0 then"
position = "at"
payload = "if self.ability.extra.h_size - (self.ability.extra.h_mod / G.GAME.fridge_mod) <= 0 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.hand:change_size(- self.ability.extra.h_mod)"
position = "at"
payload = "G.hand:change_size(- (self.ability.extra.h_mod / G.GAME.fridge_mod))"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_handsize_minus',vars={self.ability.extra.h_mod}},"
position = "at"
payload = "message = localize{type='variable',key='a_handsize_minus',vars={self.ability.extra.h_mod / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add hook to Popcorn
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Popcorn' then loc_vars = {self.ability.mult, self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Popcorn' then loc_vars = {self.ability.mult, self.ability.extra / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.mult - self.ability.extra <= 0 then"
position = "at"
payload = "if self.ability.mult - (self.ability.extra / G.GAME.fridge_mod) <= 0 then "
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.mult = self.ability.mult - self.ability.extra"
position = "at"
payload = "self.ability.mult = self.ability.mult - (self.ability.extra / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_mult_minus',vars={self.ability.extra}},"
position = "at"
payload = "message = localize{type='variable',key='a_mult_minus',vars={self.ability.extra / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add hook to Ramen
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Ramen' then loc_vars = {self.ability.x_mult, self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Ramen' then loc_vars = {self.ability.x_mult, self.ability.extra / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.x_mult - self.ability.extra <= 1 then"
position = "at"
payload = "if self.ability.x_mult - (self.ability.extra / G.GAME.fridge_mod) <= 1 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.x_mult = self.ability.x_mult - self.ability.extra"
position = "at"
payload = "self.ability.x_mult = self.ability.x_mult - (self.ability.extra / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_xmult_minus',vars={self.ability.extra}},"
position = "at"
payload = "message = localize{type='variable',key='a_xmult_minus',vars={self.ability.extra / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add hook to Seltzer
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Seltzer' then loc_vars = {self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Seltzer' then loc_vars = {self.ability.extra * G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra - 1 <= 0 then "
position = "at"
payload = "if self.ability.extra - (1 / G.GAME.fridge_mod) <= 0 then "
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.extra = self.ability.extra - 1"
position = "at"
payload = "self.ability.extra = self.ability.extra - (1 / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = self.ability.extra..'',"
position = "at"
payload = "message = self.ability.extra * G.GAME.fridge_mod..'',"
match_indent = true
times = 1







# Hopscotch Functionality --------------------------------------

    # Intercept skip tag from 
[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if G.blind_select then "
position = "after"
payload = '''
    local _tag = e.UIBox:get_UIE_by_ID('tag_container')
    G.GAME.skip_tag = _tag
'''
match_indent = true
times = 2





# Secret Society Functionality ------------------------------------

    # Rewrite card scoring functionality (includes Hammer and Chisel implementation to reduce patches)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.effect == 'Stone Card' or self.config.center.replace_base_card then
    return self.ability.bonus + (self.ability.perma_bonus or 0)
end
'''
position = "at"
payload = '''
if (self.ability.effect == 'Stone Card' and not next(SMODS.find_card('j_mxms_hammer_and_chisel'))) or self.config.center.replace_base_card then
    return self.ability.bonus + (self.ability.perma_bonus or 0)
elseif next(SMODS.find_card('j_mxms_secret_society')) then
    if self:get_id() == 2 then
        return 22 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 3 then
        return 20 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 4 then
        return 18 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 5 then
        return 16 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 6 then
        return 14 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 7 then
        return 12 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 8 then
        return 10 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 9 then
        return 8 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 10 or self:is_face() then
        return 6 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 14 then
        return 4 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
end
'''
match_indent = true
times = 1





# Hammer and Chisel Functionality ------------------------------------

    # Change stone card checks
[[patches]]
[patches.regex]
target = '=[SMODS _ "src/utils.lua"]'
pattern = "(?<pre>[\t ]*if )k == 'm_stone'(?<post>.*or G\\.P_CENTERS\\[k\\]\\.no_suit then is_stone = true end)"
position = "at"
payload = "$pre(k == 'm_stone' and not next(SMODS.find_card('j_mxms_hammer_and_chisel')))$post"
match_indent = true
times = 1

[[patches]]
[patches.regex]
target = '=[SMODS _ "src/utils.lua"]'
pattern = "(?<pre>[\t ]*if )k == 'm_stone'(?<post>.*or G\\.P_CENTERS\\[k\\]\\.no_rank then return true end)"
position = "at"
payload = "$pre(k == 'm_stone' and not next(SMODS.find_card('j_mxms_hammer_and_chisel')))$post"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.effect == 'Stone Card' or (self.config.center.no_suit and self.config.center.no_rank) then"
position = "at"
payload = "if (self.ability.effect == 'Stone Card' and not next(SMODS.find_card('j_mxms_hammer_and_chisel'))) or (self.config.center.no_suit and self.config.center.no_rank) then"
match_indent = true
times = 1

# Change rendering code for stone cards to include rank and suit
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
--If the card has a front, draw that next
if self.children.front and self.ability.effect ~= 'Stone Card' and not self.config.center.replace_base_card then
'''
position = "at"
payload = '''
--If the card has a front, draw that next
if self.children.front and (self.ability.effect ~= 'Stone Card' or next(SMODS.find_card('j_mxms_hammer_and_chisel'))) and not self.config.center.replace_base_card then
'''
match_indent = true
times = 1






# Add Soyjoke and Clown Car Functionality -----------------------------------------

    # Add joker to tracker or iterate modifier if already present
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.d_size > 0 then
    G.GAME.round_resets.discards = G.GAME.round_resets.discards + self.ability.d_size
    ease_discard(self.ability.d_size)
 end
'''
position = "after"
payload = '''
if self.ability.set == 'Joker' then
    G.GAME.current_round.jokers_purchased = G.GAME.current_round.jokers_purchased + 1
    if next(SMODS.find_card('j_mxms_clown_car')) then
        G.E_MANAGER:add_event(Event({func = function()
            for k, v in pairs(G.jokers.cards) do
                if v.config.center.key == 'j_mxms_clown_car' then
                v:juice_up(0.1,0.1)
                    v.ability.extra.mult = v.ability.extra.mult + (2 * G.GAME.soil_mod)
                    return true
                end
            end
            G.GAME.purchased_jokers[#G.GAME.purchased_jokers + 1] = self.ability.name
        return true end }))
    end
    G.E_MANAGER:add_event(Event({func = function()
        for k, v in pairs(G.GAME.purchased_jokers) do
            if v == self.ability.name then
                G.GAME.soy_mod = G.GAME.soy_mod + 0.25
                return true
            end
        end
        G.GAME.purchased_jokers[#G.GAME.purchased_jokers + 1] = self.ability.name
    return true end }))
end
'''
match_indent = true
times = 1






# Add Gambler Functionality -----------------------------------------

    # Apply modifier to Hermit
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "The Hermit" then loc_vars = {cfg.extra}
'''
position = "at"
payload = '''
elseif _c.name == "The Hermit" then loc_vars = {(cfg.extra * G.GAME.gambler_mod)}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'The Hermit' then
    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
        play_sound('timpani')
        used_tarot:juice_up(0.3, 0.5)
        ease_dollars(math.max(0,math.min(G.GAME.dollars, self.ability.extra)), true)
        return true end }))
    delay(0.6)
end
'''
position = "at"
payload = '''
if self.ability.name == 'The Hermit' then
    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
        play_sound('timpani')
        used_tarot:juice_up(0.3, 0.5)
        ease_dollars(math.max(0,math.min(G.GAME.dollars, self.ability.extra * G.GAME.gambler_mod)), true)
        return true end }))
    delay(0.6)
end
'''
match_indent = true
times = 1


    # Apply modifier to Temperance
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "Temperance" then
    local _money = 0
    if G.jokers then
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i].ability.set == 'Joker' then
                _money = _money + G.jokers.cards[i].sell_cost
            end
        end
    end
    loc_vars = {cfg.extra, math.min(cfg.extra, _money)}
'''
position = "at"
payload = '''
elseif _c.name == "Temperance" then
    local _money = 0
    if G.jokers then
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i].ability.set == 'Joker' then
                _money = _money + G.jokers.cards[i].sell_cost
            end
        end
    end
    loc_vars = {(cfg.extra * G.GAME.gambler_mod), math.min((cfg.extra * G.GAME.gambler_mod), _money)}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Temperance' then
    self.ability.money = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].ability.set == 'Joker' then
            self.ability.money = self.ability.money + G.jokers.cards[i].sell_cost
        end
    end
    self.ability.money = math.min(self.ability.money, self.ability.extra)
end
'''
position = "at"
payload = '''
if self.ability.name == 'Temperance' then
    self.ability.money = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].ability.set == 'Joker' then
            self.ability.money = self.ability.money + G.jokers.cards[i].sell_cost
        end
    end
    self.ability.money = math.min(self.ability.money, self.ability.extra * G.GAME.gambler_mod)
end
'''
match_indent = true
times = 1


    # Apply modifier to Economy Tag
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = '''
elseif name_to_check == 'Economy Tag' then loc_vars = {self.config.max}
'''
position = "at"
payload = '''
elseif name_to_check == 'Economy Tag' then loc_vars = {self.config.max * G.GAME.gambler_mod}
'''
match_indent = true
times = 1






# Add mult bonus variable to card objects-----------------------------------------

    # Create card variable
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "perma_bonus = self.ability and self.ability.perma_bonus or 0,"
position = "after"
payload = "mult_perma_bonus = self.ability and self.ability.mult_perma_bonus or 0,"
match_indent = true
times = 1


    # Apply variable to mult calc
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
function Card:get_chip_mult()
    if self.debuff then return 0 end
    if self.ability.set == 'Joker' then return 0 end
    if self.ability.effect == "Lucky Card" then 
        if pseudorandom('lucky_mult') < G.GAME.probabilities.normal/5 then
            self.lucky_trigger = true
            return self.ability.mult
        else
            return 0
        end
    else  
        return self.ability.mult
    end
end
'''
position = "at"
payload = '''
function Card:get_chip_mult()
    if self.debuff then return 0 end
    if self.ability.set == 'Joker' then return 0 end
    if self.ability.effect == "Lucky Card" then 
        if pseudorandom('lucky_mult') < G.GAME.probabilities.normal/5 then
            self.lucky_trigger = true
            return self.ability.mult + self.ability.mult_perma_bonus
        else
            return 0
        end
    else  
        return self.ability.mult + self.ability.mult_perma_bonus
    end
end'''
match_indent = true
times = 1


    # Add variable to card description
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
loc_vars = { playing_card = not not self.base.colour, value = self.base.value, suit = self.base.suit, colour = self.base.colour,
    nominal_chips = self.base.nominal > 0 and self.base.nominal or nil,
    bonus_chips = (self.ability.bonus + (self.ability.perma_bonus or 0)) > 0 and (self.ability.bonus + (self.ability.perma_bonus or 0)) or nil,
}
'''
position = "at"
payload = '''
loc_vars = { playing_card = not not self.base.colour, value = self.base.value, suit = self.base.suit, colour = self.base.colour,
    nominal_chips = self.base.nominal > 0 and self.base.nominal or nil,
    bonus_chips = (self.ability.bonus + (self.ability.perma_bonus or 0)) > 0 and (self.ability.bonus + (self.ability.perma_bonus or 0)) or nil,
    bonus_mult = (self.ability.mult_perma_bonus > 0 and self.ability.mult_perma_bonus) or nil
}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if specific_vars.bonus_chips then
    localize{type = 'other', key = 'card_extra_chips', nodes = desc_nodes, vars = {specific_vars.bonus_chips}}
end
'''
position = "after"
payload = '''
if specific_vars.bonus_mult then
    localize{type = 'other', key = 'card_extra_mult', nodes = desc_nodes, vars = {specific_vars.bonus_mult}}
end
'''
match_indent = true
times = 1






# Add Virus Functionality -----------------------------------------

    # Apply Virus search in get_flush
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''
function get_flush(hand)
  local ret = {}
  local four_fingers = next(find_joker('Four Fingers'))
  local suits = SMODS.Suit.obj_buffer
  if #hand < (5 - (four_fingers and 1 or 0)) then return ret else
'''
position = "at"
payload = '''
function get_flush(hand)
  local ret = {}
  local four_fingers = next(find_joker('Four Fingers'))
  local virus = next(SMODS.find_card('j_mxms_virus'))
  local suits = SMODS.Suit.obj_buffer
  if #hand < (5 - (four_fingers and 1 or virus and 3 or 0)) then return ret else
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''
if flush_count >= (5 - (four_fingers and 1 or 0)) then
'''
position = "at"
payload = '''
if flush_count >= (5 - (four_fingers and 1 or (virus and flush_count == #hand) and 3 or 0)) then
'''
match_indent = true
times = 1






# Add Salt Circle Functionality -----------------------------------------

    # Iterate spectrals_used if spectral card is used_tarot
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.consumeable.max_highlighted then
    update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''})
end
    '''
position = "after"
payload = '''

if self.ability.set == 'Spectral' then
    G.GAME.spectrals_used = G.GAME.spectrals_used + 1
end
'''
match_indent = true
times = 1






# Add Coupon Functionality -----------------------------------------

    # Modify card shop creation
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
if polled_rate > check_rate and polled_rate <= check_rate + v.val then
    local card = create_card(v.type, area, nil, nil, nil, nil, nil, 'sho')
'''
position = "at"
payload = '''
if polled_rate > check_rate and polled_rate <= check_rate + v.val then
    local card = create_card(v.type, area, nil, nil, nil, nil, nil, 'sho')
    local coupons = SMODS.find_card('j_mxms_coupon')
    if card.ability.set == 'Joker' and next(coupons) then
        for k, v in pairs(coupons) do
            if pseudorandom('cou' .. G.GAME.round_resets.ante, 1 * G.GAME.probabilities.normal, 10) == 10 then
                card.cost = 0
                v:juice_up(0.3, 0.4)
                break
            end
        end
    end
'''
match_indent = true
times = 1






# Add Power Creep Functionality -----------------------------------------

    # Modify shop costs
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.area and self.ability.couponed and (self.area == G.shop_jokers or self.area == G.shop_booster) then self.cost = 0 end
self.sell_cost_label = self.facing == 'back' and '?' or self.sell_cost
'''
position = "after"
payload = '''
    self.cost = self.cost * G.GAME.creep_mod
'''
match_indent = true
times = 1






# Add Stop Sign Functionality -----------------------------------------

    # Hook into rotating cards in common_events
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
function reset_idol_card()
    G.GAME.current_round.idol_card.rank = 'Ace'
    G.GAME.current_round.idol_card.suit = 'Spades'
    local valid_idol_cards = {}
    for k, v in ipairs(G.playing_cards) do
        if v.ability.effect ~= 'Stone Card' then
            if not SMODS.has_no_suit(v) and not SMODS.has_no_rank(v) then
                valid_idol_cards[#valid_idol_cards+1] = v
            end
        end
    end
    if valid_idol_cards[1] then 
        local idol_card = pseudorandom_element(valid_idol_cards, pseudoseed('idol'..G.GAME.round_resets.ante))
        G.GAME.current_round.idol_card.rank = idol_card.base.value
        G.GAME.current_round.idol_card.suit = idol_card.base.suit
        G.GAME.current_round.idol_card.id = idol_card.base.id
    end
end

function reset_mail_rank()
    G.GAME.current_round.mail_card.rank = 'Ace'
    local valid_mail_cards = {}
    for k, v in ipairs(G.playing_cards) do
        if v.ability.effect ~= 'Stone Card' then
            if not SMODS.has_no_rank(v) then
                valid_mail_cards[#valid_mail_cards+1] = v
            end
        end
    end
    if valid_mail_cards[1] then 
        local mail_card = pseudorandom_element(valid_mail_cards, pseudoseed('mail'..G.GAME.round_resets.ante))
        G.GAME.current_round.mail_card.rank = mail_card.base.value
        G.GAME.current_round.mail_card.id = mail_card.base.id
    end
end

function reset_ancient_card()
    local ancient_suits = {}
    for k, v in ipairs({'Spades','Hearts','Clubs','Diamonds'}) do
        if v ~= G.GAME.current_round.ancient_card.suit then ancient_suits[#ancient_suits + 1] = v end
    end
    local ancient_card = pseudorandom_element(ancient_suits, pseudoseed('anc'..G.GAME.round_resets.ante))
    G.GAME.current_round.ancient_card.suit = ancient_card
end

function reset_castle_card()
    G.GAME.current_round.castle_card.suit = 'Spades'
    local valid_castle_cards = {}
    for k, v in ipairs(G.playing_cards) do
        if v.ability.effect ~= 'Stone Card' then
            if not SMODS.has_no_suit(v) then
                valid_castle_cards[#valid_castle_cards+1] = v
            end
        end
    end
    if valid_castle_cards[1] then 
        local castle_card = pseudorandom_element(valid_castle_cards, pseudoseed('cas'..G.GAME.round_resets.ante))
        G.GAME.current_round.castle_card.suit = castle_card.base.suit
    end
end
'''
position = "at"
payload = '''
function reset_idol_card()
    if not next(SMODS.find_card('j_mxms_stop_sign')) and G.GAME.round ~= 1 then
        G.GAME.current_round.idol_card.rank = 'Ace'
        G.GAME.current_round.idol_card.suit = 'Spades'
        local valid_idol_cards = {}
        for k, v in ipairs(G.playing_cards) do
            if not SMODS.has_no_suit(v) and not SMODS.has_no_rank(v) then
                valid_idol_cards[#valid_idol_cards+1] = v
            end
        end
        if valid_idol_cards[1] then 
            local idol_card = pseudorandom_element(valid_idol_cards, pseudoseed('idol'..G.GAME.round_resets.ante))
            G.GAME.current_round.idol_card.rank = idol_card.base.value
            G.GAME.current_round.idol_card.suit = idol_card.base.suit
            G.GAME.current_round.idol_card.id = idol_card.base.id
        end
    end
end

function reset_mail_rank()
    if not next(SMODS.find_card('j_mxms_stop_sign')) and G.GAME.round ~= 1 then
        G.GAME.current_round.mail_card.rank = 'Ace'
        local valid_mail_cards = {}
        for k, v in ipairs(G.playing_cards) do
            if not SMODS.has_no_rank(v) then
                valid_mail_cards[#valid_mail_cards+1] = v
            end
        end
        if valid_mail_cards[1] then 
            local mail_card = pseudorandom_element(valid_mail_cards, pseudoseed('mail'..G.GAME.round_resets.ante))
            G.GAME.current_round.mail_card.rank = mail_card.base.value
            G.GAME.current_round.mail_card.id = mail_card.base.id
        end
    end
end

function reset_ancient_card()
    if not next(SMODS.find_card('j_mxms_stop_sign')) and G.GAME.round ~= 1 then
        local ancient_suits = {}
        for k, v in ipairs({'Spades','Hearts','Clubs','Diamonds'}) do
            if v ~= G.GAME.current_round.ancient_card.suit then ancient_suits[#ancient_suits + 1] = v end
        end
        local ancient_card = pseudorandom_element(ancient_suits, pseudoseed('anc'..G.GAME.round_resets.ante))
        G.GAME.current_round.ancient_card.suit = ancient_card
    end
end

function reset_castle_card()
    if not next(SMODS.find_card('j_mxms_stop_sign')) and G.GAME.round ~= 1 then
        G.GAME.current_round.castle_card.suit = 'Spades'
        local valid_castle_cards = {}
        for k, v in ipairs(G.playing_cards) do
            if not SMODS.has_no_suit(v) then
                valid_castle_cards[#valid_castle_cards+1] = v
            end
        end
        if valid_castle_cards[1] then 
            local castle_card = pseudorandom_element(valid_castle_cards, pseudoseed('cas'..G.GAME.round_resets.ante))
            G.GAME.current_round.castle_card.suit = castle_card.base.suit
        end
    end
end
'''
match_indent = true


    # Hook into To Do List
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'To Do List' and not context.blueprint then
'''
position = "at"
payload = '''
if self.ability.name == 'To Do List' and not context.blueprint and (not next(SMODS.find_card('j_mxms_stop_sign')) and G.GAME.round ~= 1) then
'''
match_indent = true
times = 1






# Add Soil and Group Chat Functionality (yes this really sucked to implement) -------------------------------------------------

    # Hook into Campfire
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Campfire' and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Campfire' and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Flash Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Flash Card' and not context.blueprint then
    self.ability.mult = self.ability.mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Flash Card' and not context.blueprint then
    self.ability.mult = self.ability.mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Red Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Red Card' and not context.blueprint then
    self.ability.mult = self.ability.mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Red Card' and not context.blueprint then
    self.ability.mult = self.ability.mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Hologram
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Hologram' and (not context.blueprint)
    and context.cards and context.cards[1] then
        self.ability.x_mult = self.ability.x_mult + #context.cards*self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Hologram' and (not context.blueprint)
    and context.cards and context.cards[1] then
        self.ability.x_mult = self.ability.x_mult + (#context.cards*self.ability.extra*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Madness
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Madness' and not context.blueprint and not context.blind.boss then
    self.ability.x_mult = self.ability.x_mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Madness' and not context.blueprint and not context.blind.boss then
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Ceremonial Dagger
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.mult = self.ability.mult + sliced_card.sell_cost*2
'''
position = "at"
payload = '''
self.ability.mult = self.ability.mult + (sliced_card.sell_cost*2*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Canio
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.caino_xmult = self.ability.caino_xmult + faces*self.ability.extra
'''
position = "at"
payload = '''
self.ability.caino_xmult = self.ability.caino_xmult + (faces*self.ability.extra*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.caino_xmult = self.ability.caino_xmult + face_cards*self.ability.extra
'''
position = "at"
payload = '''
self.ability.caino_xmult = self.ability.caino_xmult + (face_cards*self.ability.extra*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Glass Joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.x_mult = self.ability.x_mult + self.ability.extra*glasses
'''
position = "at"
payload = '''
self.ability.x_mult = self.ability.x_mult + (self.ability.extra*glasses*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.x_mult = self.ability.x_mult + self.ability.extra*glass_cards
'''
position = "at"
payload = '''
self.ability.x_mult = self.ability.x_mult + (self.ability.extra*glass_cards*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
self.ability.x_mult = self.ability.x_mult + self.ability.extra*shattered_glass
'''
position = "at"
payload = '''
self.ability.x_mult = self.ability.x_mult + (self.ability.extra*shattered_glass*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Constellation
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Constellation' and not context.blueprint and context.consumeable.ability.set == 'Planet' then
    self.ability.x_mult = self.ability.x_mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Constellation' and not context.blueprint and context.consumeable.ability.set == 'Planet' then
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Yorick
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Yorick' and not context.blueprint then
    if self.ability.yorick_discards <= 1 then
        self.ability.yorick_discards = self.ability.extra.discards
        self.ability.x_mult = self.ability.x_mult + self.ability.extra.xmult
'''
position = "at"
payload = '''
if self.ability.name == 'Yorick' and not context.blueprint then
    if self.ability.yorick_discards <= 1 then
        self.ability.yorick_discards = self.ability.extra.discards
        self.ability.x_mult = self.ability.x_mult + (self.ability.extra.xmult * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Castle
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
context.other_card:is_suit(G.GAME.current_round.castle_card.suit) and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + self.ability.extra.chip_mod
'''
position = "at"
payload = '''
context.other_card:is_suit(G.GAME.current_round.castle_card.suit) and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + (self.ability.extra.chip_mod * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Hit the Road
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Hit the Road' and
not context.other_card.debuff and
context.other_card:get_id() == 11 and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Hit the Road' and
not context.other_card.debuff and
context.other_card:get_id() == 11 and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Rocket
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Rocket' and G.GAME.blind.boss then
    self.ability.extra.dollars = self.ability.extra.dollars + self.ability.extra.increase
'''
position = "at"
payload = '''
if self.ability.name == 'Rocket' and G.GAME.blind.boss then
    self.ability.extra.dollars = self.ability.extra.dollars + (self.ability.extra.increase * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Egg
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Egg' then
    self.ability.extra_value = self.ability.extra_value + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Egg' then
    self.ability.extra_value = self.ability.extra_value + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Gift Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
for k, v in ipairs(G.jokers.cards) do
    if v.set_cost then 
        v.ability.extra_value = (v.ability.extra_value or 0) + self.ability.extra
        v:set_cost()
    end
end
for k, v in ipairs(G.consumeables.cards) do
    if v.set_cost then 
        v.ability.extra_value = (v.ability.extra_value or 0) + self.ability.extra
        v:set_cost()
    end
end
'''
position = "at"
payload = '''
for k, v in ipairs(G.jokers.cards) do
    if v.set_cost then 
        v.ability.extra_value = (v.ability.extra_value or 0) + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
        v:set_cost()
    end
end
for k, v in ipairs(G.consumeables.cards) do
    if v.set_cost then 
        v.ability.extra_value = (v.ability.extra_value or 0) + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
        v:set_cost()
    end
end
'''
match_indent = true
times = 1


    # Hook into Lucky Cat
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Lucky Cat' and context.other_card.lucky_trigger and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Lucky Cat' and context.other_card.lucky_trigger and not context.blueprint then
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Wee joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Wee Joker' and
    context.other_card:get_id() == 2 and not context.blueprint then
        self.ability.extra.chips = self.ability.extra.chips + self.ability.extra.chip_mod
'''
position = "at"
payload = '''
if self.ability.name == 'Wee Joker' and
    context.other_card:get_id() == 2 and not context.blueprint then
        self.ability.extra.chips = self.ability.extra.chips + (self.ability.extra.chip_mod * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Spare Trousers
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Spare Trousers' and (next(context.poker_hands['Two Pair']) or next(context.poker_hands['Full House'])) and not context.blueprint then
    self.ability.mult = self.ability.mult + self.ability.extra
'''
position = "at"
payload = '''
if self.ability.name == 'Spare Trousers' and (next(context.poker_hands['Two Pair']) or next(context.poker_hands['Full House'])) and not context.blueprint then
    self.ability.mult = self.ability.mult + (self.ability.extra * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Square Joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Square Joker' and #context.full_hand == 4 and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + self.ability.extra.chip_mod
'''
position = "at"
payload = '''
if self.ability.name == 'Square Joker' and #context.full_hand == 4 and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + (self.ability.extra.chip_mod * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Runner
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Runner' and next(context.poker_hands['Straight']) and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + self.ability.extra.chip_mod
'''
position = "at"
payload = '''
if self.ability.name == 'Runner' and next(context.poker_hands['Straight']) and not context.blueprint then
    self.ability.extra.chips = self.ability.extra.chips + (self.ability.extra.chip_mod * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Vampire
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if #enhanced > 0 then 
    self.ability.x_mult = self.ability.x_mult + self.ability.extra*#enhanced
'''
position = "at"
payload = '''
if #enhanced > 0 then 
    self.ability.x_mult = self.ability.x_mult + (self.ability.extra*#enhanced*G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1


    # Hook into Ride the Bus
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Ride the Bus' and not context.blueprint then
    local faces = false
    for i = 1, #context.scoring_hand do
        if context.scoring_hand[i]:is_face() then faces = true end
    end
    if faces then
        local last_mult = self.ability.mult
        self.ability.mult = 0
        if last_mult > 0 then 
            return {
                card = self,
                message = localize('k_reset')
            }
        end
    else
        self.ability.mult = self.ability.mult + self.ability.extra
    end
'''
position = "at"
payload = '''
if self.ability.name == 'Ride the Bus' and not context.blueprint then
    local faces = false
    for i = 1, #context.scoring_hand do
        if context.scoring_hand[i]:is_face() then faces = true end
    end
    if faces then
        local last_mult = self.ability.mult
        self.ability.mult = 0
        if last_mult > 0 then 
            return {
                card = self,
                message = localize('k_reset')
            }
        end
    else
        self.ability.mult = self.ability.mult + (self.ability.extra * G.GAME.soil_mod)
        local groupchats = SMODS.find_card('j_mxms_group_chat')
        if next(groupchats) then
            for k, v in pairs(groupchats) do
                v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
                v:juice_up(0.3, 0.4)
            end
        end
    end
'''
match_indent = true
times = 1


    # Hook into Obelisk
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Obelisk' and not context.blueprint then
    local reset = true
    local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)
    for k, v in pairs(G.GAME.hands) do
        if k ~= context.scoring_name and v.played >= play_more_than and v.visible then
            reset = false
        end
    end
    if reset then
        if self.ability.x_mult > 1 then
            self.ability.x_mult = 1
            return {
                card = self,
                message = localize('k_reset')
            }
        end
    else
        self.ability.x_mult = self.ability.x_mult + self.ability.extra
    end
'''
position = "at"
payload = '''
if self.ability.name == 'Obelisk' and not context.blueprint then
    local reset = true
    local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)
    for k, v in pairs(G.GAME.hands) do
        if k ~= context.scoring_name and v.played >= play_more_than and v.visible then
            reset = false
        end
    end
    if reset then
        if self.ability.x_mult > 1 then
            self.ability.x_mult = 1
            return {
                card = self,
                message = localize('k_reset')
            }
        end
    else
        self.ability.x_mult = self.ability.x_mult + (self.ability.extra * G.GAME.soil_mod)
        local groupchats = SMODS.find_card('j_mxms_group_chat')
        if next(groupchats) then
            for k, v in pairs(groupchats) do
                v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
                v:juice_up(0.3, 0.4)
            end
        end
    end
'''
match_indent = true
times = 1


    # Hook into Green Joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Green Joker' and not context.blueprint then
    self.ability.mult = self.ability.mult + self.ability.extra.hand_add
'''
position = "at"
payload = '''
if self.ability.name == 'Green Joker' and not context.blueprint then
    self.ability.mult = self.ability.mult + (self.ability.extra.hand_add * G.GAME.soil_mod)
    local groupchats = SMODS.find_card('j_mxms_group_chat')
    if next(groupchats) then
        for k, v in pairs(groupchats) do
            v.ability.extra.chips = v.ability.extra.chips + 2 * G.GAME.soil_mod
            v:juice_up(0.3, 0.4)
        end
    end
'''
match_indent = true
times = 1






# Add better Unpleasant Gradient compat with Flower Pot -------------------------------------------------

    # Hook into Flower Pot
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Flower Pot' then
    local suits = {
        ['Hearts'] = 0,
        ['Diamonds'] = 0,
        ['Spades'] = 0,
        ['Clubs'] = 0
    }
'''
position = "at"
payload = '''
if self.ability.name == 'Flower Pot' then
    local unpleasant = SMODS.find_card('j_mxms_unpleasant_gradient')
    if next(unpleasant) then
        if unpleasant[1].ability.extra.triggered then
            return {
                message = localize{type='variable',key='a_xmult',vars={self.ability.extra}},
                Xmult_mod = self.ability.extra
            }
        end
    end
    local suits = {
        ['Hearts'] = 0,
        ['Diamonds'] = 0,
        ['Spades'] = 0,
        ['Clubs'] = 0
    }
'''
match_indent = true
times = 1






# Add Stone Thrower functionality

    # Modify chances to guarantee break with Stone Thrower
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''if scoring_hand and SMODS.has_enhancement(card, 'm_glass') and not card.debuff and pseudorandom('glass') < G.GAME.probabilities.normal/(card.ability.name == 'Glass Card' and card.ability.extra or G.P_CENTERS.m_glass.config.extra) then'''
position = "at"
payload = '''if scoring_hand and SMODS.has_enhancement(card, 'm_glass') and not card.debuff and (pseudorandom('glass') < G.GAME.probabilities.normal/(card.ability.name == 'Glass Card' and card.ability.extra or G.P_CENTERS.m_glass.config.extra) or next(SMODS.find_card('j_mxms_stone_thrower'))) then'''
match_indent = true
times = 1





# ------------------------------------- CHALLENGE MODIFIERS -------------------------------------

    #Blind Size Modifier
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''
self.chips = get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling
'''
position = "after"
payload = '''
if G.GAME.modifiers.mxms_X_blind_size then
    self.chips = self.chips*G.GAME.modifiers.mxms_X_blind_size
end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''
local blind_amt = get_blind_amount(G.GAME.round_resets.blind_ante)*blind_choice.config.mult*G.GAME.starting_params.ante_scaling
'''
position = "after"
payload = '''
if G.GAME.modifiers.mxms_X_blind_size then
    blind_amt = blind_amt*G.GAME.modifiers.mxms_X_blind_size
end
'''
match_indent = true
times = 1


    #Target Practice Check
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then
    game_won = true
    G.GAME.won = true
end
'''
position = "at"
payload = '''
if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then
    if G.GAME.modifiers.mxms_bullseye_requirement and G.GAME.modifiers.mxms_bullseye_requirement > SMODS.find_card('j_mxms_bullseye')[1].ability.extra.chips then
        game_over = true
    else
        game_won = true
        G.GAME.won = true
    end
end
'''
match_indent = true
times = 1





# ------------------------------------------ NEW LOGIC ------------------------------------------

# Add new shop appearance gates -----------------------------------------

    # Create modifier and tracker variables
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif v.enhancement_gate then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        if SMODS.has_enhancement(vv, v.enhancement_gate) then
            add = true
        end
    end
'''
position = "after"
payload = '''
elseif v.enhancement_gate_set then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        for kkk, vvv in pairs(v.enhancement_gate_set) do
            if SMODS.has_enhancement(vv, vvv) then
                add = true
            end
        end
    end
elseif v.edition_gate_set then
    add = nil
    for kk, vv in pairs(v.edition_gate_set) do
        for kkk, vvv in pairs(G.playing_cards) do
            if vvv.edition and vvv.edition.type == vv then
                add = true
            end
        end
        for kkk, vvv in ipairs(G.jokers) do
            if vvv.edition and vvv.edition.type == vv then
                add = true
            end
        end
    end
elseif v.seal_gate then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        if v.seal then
            add = true
        end
    end
elseif v.joker_gate then
    add = nil
    if next(SMODS.find_card(v.joker_gate)) then
        add = true
    end
'''
match_indent = true
times = 1

# Change highlight limit to be mutable
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = "self.config.highlighted_limit = config.highlight_limit or 5"
position = "at"
payload = "self.config.highlighted_limit = config.highlight_limit or G.GAME.modifiers.mxms_highlight_limit or 5"
match_indent = true